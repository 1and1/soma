SOMA Authentication Protocol
============================

1.Key Exchange - Phase I, Client
----------------------------------

The client generates `auth.Kex` and sends it to the server
as `application/json` body at `POST /authenticate/`.

The `Kex` must contain the following fields:
* Public, hex encoded string
* InitializationVector, hex encoded string

Values set as Request are ignored by the server.
The client's `Kex.count` is initialized as the uint zero value
`0`.

2.Key Exchange - Phase II, Server
-----------------------------------

The server receives the `Kex` from the client.
It takes the public key from `Public` and saves it as `peer`.
It generates its own keypair via `Kex.GenerateNewKeypair()`.
It saves the client IP address via `Kex.SetIPAddress()`.
It assigns an UUIDv4 via `Kex.GenerateNewRequestID()`.
It saves the time of the request as `Kex.SetTimeUTC()`.

The server replies the client with a `Kex` of its own. This
must contain the following fields:
* Public, hex encoded string
* Request, uuid string
* InitializationVector, hex encoded string

The InitializationVector that the client sent is repeated as
confirmation of acceptance. A different InitializationVector aborts
the kex exchange. The server may freely reject the client submitted
InitializationVector.

The server keeps the `Kex` stored in memory until it is either
used or expires due to a present timeout. A periodic prune job should
remove unused expired `Kex` structures.

The server may implement a limit on the number of pending key
exchanges to protect against memory exhaustion attacks.

The server's `Kex.count` is initialized as the uint zero value
`0`.

3.Key Exchange - Phase III, Client
----------------------------------

The client receives the `Kex` reply from the server.
It takes the server's public key from `Public` and saves it as `peer`.
It saves the server assigned `Request` UUID as the identifier for this
exchange.
It verifies the server has accepted the proposed InitializationVector.

4.Data Exchange - Phase 1, Client
---------------------------------

The client takes the request data it wants to send to the server and
encodes it as JSON. This plaintext playload is then encrypted using
the authenticated encryption provided by `nacl/box.Seal` (using
Curve25519, XSalsa20 and Poly1305).

This is done with the client's private key, the server's public key
and a nonce derived from the shared, public InitializationVector.

The nonce is generated by decoding the hex string, and using its bytes
to initialize a 24 Byte BigInt number. Its absolute value is taken to
ensure it is a positive number.
The `count` is increased by 1 for every requested nonce. It is added
to BigInt and represents the nonce to use for this message.

The resulting cipherText is transport encoded with `base64.StdEncoding`
and sent to the server as `application/octet-stream`.

Example URI to a new password token would for example be:
`POST /authenticate/token/d1ee59a6-cec0-493d-be72-3d32a1dab028`

5.Data Exchange - Phase 2, Server
---------------------------------

The server uses the request UUID from the URI to look up the
`Kex`. If verifies validity (not expired) and source IP. Using
`nacl/box.Open` it tries to unseal the ciphertext after removing the
base64 transport encoding and incrementing the counter.
The resulting JSON data is used to process the request.

Referencing a pending `Kex` by UUID from the same source IP
does not invalidate the exchange. All other faults during this stage
abort the exchange and delete the `Kex` on the server side.
All failures are reported to the client as `401 - Unauthorized`.

Since authenticated encryption is used, no further checks are required
if the server is able to decrypt the client message.

For the reply, the server as well increments `Kex.count` again
and uses `nacl/box.Seal` to encrypt the JSON result.
It is transport encoded with `base64.StdEncoding` and sent as
`application/octet-stream`.

After using the `Kex` once (successfully or not), the server
deletes it.

6.Data Exchange - Phase 3, Client
---------------------------------

The client decrypts the received ciphertext using `nacl/box.Open`
after undoing the transport encoding and incrementing the counter.

7.Remarks
---------

The encryption scheme used by `nacl/box` fails and opens itself up to
attacks if for a given combination of keypairs the same nonce is used
for more than one message.

The nonce in this implementation is generated by reading 192 bits from
Go's interface to the platforms secure entropy source, `crypto/rand`.
The counters that client and server must lockstep independently ensure
that no nonce is reused and if one party fails, the other aborts the
key exchange since decryption fails with mismatching nonce values.

All keypairs are generated by reading 1024 bits from `crypto/rand` and
hashing them down to 256 bit using Blake2b as hash algorithm. The
resulting 256 bit are used with `nacl/box.GenerateKey` to generate the
keypairs. The hashing follow's the recommendation from DJB's
Curve25519 paper.

All keypairs are only used for a single key exchange, with randomly
initialized nonces that implement a counter to prevent reuse. This
failure mode is this considered sufficiently handled.

Key exchange UUIDs referenced by the wrong client IP address do not
result in rejection of the key exchange. This is so that running
exchanges can not be interrupted by someone guessing UUIDs really
fast. This is the internet after all.
